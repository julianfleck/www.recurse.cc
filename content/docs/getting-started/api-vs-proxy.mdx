---
title: API vs Proxy
description: Understanding the differences and when to choose what
icon: git-compare
---

Recurse offers two main ways to interact with your knowledge: the **API** for manual control and the **Proxy** for automatic context injection. Understanding the differences helps you choose the right approach for your use case.

---

## The API Approach

The REST API gives you direct access to upload content, search your knowledge graph, and retrieve specific information.

### What You Can Do

- **Upload sources** - Documents, text, URLs, files
- **Search** - Semantic search, keyword search, filtered queries
- **Retrieve** - Get specific nodes, frames, or relationships
- **Manage** - Organize with scopes, track jobs, manage metadata

### Characteristics

- ‚úÖ **Full control** - You decide exactly what to search and when
- ‚úÖ **Flexible** - Build any workflow you need
- ‚úÖ **Explicit** - Clear separation between your app and Recurse
- ‚ö†Ô∏è **More code** - You need to handle search and context assembly

### Example Use Case

```javascript
// Your application logic
const searchResults = await fetch('https://api.recurse.cc/search/?query=semantic:machine learning', {
  headers: { 'X-API-Key': apiKey }
});

// Manually assemble context
const context = searchResults.nodes.map(n => n.content).join('\n\n');

// Use in your prompt
const prompt = `Context: ${context}\n\nQuestion: What is RAGE?`;
```

**Best for:** Custom search interfaces, data analysis tools, batch processing, workflows where you need explicit control.

---

## The Proxy Approach

The proxy automatically enriches your AI API calls with relevant context from your knowledge graph‚Äîno manual search or context assembly needed.

### What You Can Do

- **Route requests** - Point your OpenAI client to Recurse's proxy
- **Automatic context** - Relevant knowledge is added automatically
- **Persistence** - Optionally save useful outputs back to your graph
- **Works everywhere** - Any OpenAI-compatible API

### Characteristics

- ‚úÖ **Automatic** - Context injection happens transparently
- ‚úÖ **Simple** - Just change your API endpoint
- ‚úÖ **Hands-off** - No manual search or context management
- ‚ö†Ô∏è **Less control** - You can't fine-tune search queries directly

### Example Use Case

```javascript
// Just point to the proxy - context added automatically!
const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
  baseURL: 'https://api.recurse.cc/proxy/https://api.openai.com/v1/',
  defaultHeaders: {
    'X-API-Key': process.env.RECURSE_API_KEY,
    'X-Recurse-Scope': 'my-project'
  }
});

// Use normally - Recurse handles context
const completion = await client.chat.completions.create({
  model: 'gpt-4o-mini',
  messages: [{ role: 'user', content: 'What is RAGE?' }]
});
```

**Best for:** Chat applications, AI assistants, automatic knowledge integration, when you want context without thinking about it.

---

## Key Differences

| Aspect | API | Proxy |
|--------|-----|-------|
| **Control** | Full control over searches | Automatic context selection |
| **Complexity** | More code, more flexibility | Less code, simpler setup |
| **Use Case** | Custom workflows, search UIs | Chat apps, AI assistants |
| **Context Assembly** | Manual | Automatic |
| **Search Queries** | Explicit, customizable | Implicit, based on conversation |
| **Integration** | Call API, use results | Change endpoint, use normally |

---

## When to Use Each

### Use the API When:

- üéØ You need **specific search queries** (e.g., "find all frames about authentication")
- üîß You're building **custom workflows** or interfaces
- üìä You want to **analyze your knowledge graph** directly
- üé® You're creating **search interfaces** or knowledge browsers
- ‚öôÔ∏è You need **precise control** over what context is used

### Use the Proxy When:

- üí¨ You're building **chat applications** or AI assistants
- ü§ñ You want **automatic context injection** without manual work
- üöÄ You prefer **simple integration** (just change the endpoint)
- üìù You want AI responses **grounded in your knowledge** automatically
- ‚ö° You're building **applications that talk to users**

---

## Using Both Together

You don't have to choose‚Äîmany applications use both:

**Pattern 1: API for ingestion, Proxy for interaction**
- Upload content via API (full control)
- Route user chats through proxy (automatic context)

**Pattern 2: API for specific queries, Proxy for general chat**
- Use API when you need specific search results
- Use proxy for general conversation

**Pattern 3: API for management, Proxy for end users**
- Admin tools use API for content management
- End-user apps use proxy for chat features

---

## Migration Path

Starting with one doesn't lock you in:

- **Start with API** ‚Üí Add proxy later for chat features
- **Start with Proxy** ‚Üí Add API for custom search needs
- **Use both** ‚Üí Get the best of both worlds

---

## Related Guides

<Cards>
  <Card href="/docs/getting-started/quickstart" title="Quickstart">
    Get started with the API in 5 minutes
  </Card>
  
  <Card href="/docs/guides/using-the-proxy" title="Using the Proxy">
    Complete guide to proxy integration
  </Card>
  
  <Card href="/docs/concepts" title="Core Concepts">
    Understand how RAGE and frames work
  </Card>
</Cards>

